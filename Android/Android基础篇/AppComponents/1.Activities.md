# Activity


## 1. Activity介绍

  Activity 是Android APP主要组件之一。它们是用户与App之间交互的入口，Activity类作为App与用户交互的入口点，提供应用程序绘制其UI的窗口,该窗口通常填充屏幕，但可能小于屏幕，并浮动在其他窗口的顶部.通常情况下，一个Activity在应用程序中实现一个屏幕。

  大多数的应用程序都包含多个屏幕的展示，也就是说包含多个Activity，通常，应用程序中的一个Activity被指定为主要Activity，这是用户启动应用程序时显示的第一个屏幕，然后，每个Activity可以启动另一个Activity。应用程序内的activity之间通常只有最小的依赖关系，而且，activity经常启动属于其他应用程序的activity。
## 2. Manifest配置

  为了要使用activity，必须在App Manifest清单文件中注册activity，并声明相关属性。

- **声明Activity**

        <manifest ... >
          <application ... >
              <activity android:name=".ExampleActivity" />
              ...
          </application ... >
          ...
        </manifest >

- **声明intent filter**

   intent filter 提供了基于显式请求启动活动的能力，也提供了隐式请求。

        <activity android:name=".ExampleActivity" android:icon="@drawable/app_icon">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/plain" />
            </intent-filter>
        <activity>
        
        
        // Create the text message with a string
        Intent sendIntent = new Intent();
        sendIntent.setAction(Intent.ACTION_SEND);
        sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
        sendIntent.setType("text/plain");
        // Start the activity
        startActivity(sendIntent);
- **声明permissions**

  您可以使用清单的<activity>标签来控制哪些应用可以开始特定的activity。如果您为特定活动声明了<uses-permission>元素，那么调用活动必须具有匹配的<uses-permission>元素。
  
        <manifest>
        <activity android:name="...."
           android:permission=”com.google.socialapp.permission.SHARE_POST”
        
        />
        
        <manifest>
           <uses-permission android:name="com.google.socialapp.permission.SHARE_POST" />
        </manifest>
        
## 3. Activity 生命周期

### 3.1 生命周期介绍

  当用户浏览，退出并返回到您的应用程序时，您的应用程序中的Activity实例将在其生命周期中通过不同的状态转换。Activity类提供了许多回调方法，允许Activity知道状态已更改：系统正在创建，停止或恢复activity，或销毁activity所在的进程。
  
  通过生命周期回调方法，我们能够适当的处理在各种操作情景下的状况，从而避免如下场景：
-   如果用户在使用您的应用程序时收到通话或切换到其他应用程序，则会崩溃。
-   当用户没有积极使用它时，消耗宝贵的系统资源。
-   如果用户离开您的应用程序并在以后返回，则丢失用户的进度。
-   当屏幕在横向和纵向方向之间旋转时，会损坏或丢失用户的进度。

### 3.2 生命周期图
    
![image](https://developer.android.com/guide/components/images/activity_lifecycle.png)

### 3.3 生命周期回调方法

- **onCreate()**

  此回调方法必须实现。当系统首次创建activity时触发该回调。在activity创建时，activity进入创建状态。
  
  在onCreate（）方法中，您可以执行基本的应用程序启动逻辑，该逻辑在整个活动的整个生命周期中应该只发生一次。例如，您的onCreate（）的实现可能会初始化数据，初始化后台线程并实例化一些类范围变量。最重要的是，您必须调用setContentView（）来定义活动用户界面的布局。
  
  此方法接收参数savedInstanceState，该参数是包含活动先前保存状态的Bundle对象。如果活动以前从未存在，则Bundle对象的值为null。
  
  
    TextView mTextView;
    
    // some transient state for the activity instance
    String mGameState;
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        // call the super class onCreate to complete the creation of activity like
        // the view hierarchy
        super.onCreate(savedInstanceState);
    
        // recovering the instance state
        if (savedInstanceState != null) {
            mGameState = savedInstanceState.getString(GAME_STATE_KEY);
        }
    
        // set the user interface layout for this Activity
        // the layout file is defined in the project res/layout/main_activity.xml file
        setContentView(R.layout.main_activity);
    
        // initialize member TextView so we can manipulate it later
        mTextView = (TextView) findViewById(R.id.text_view);
    }
    
    // This callback is called only when there is a saved instance previously saved using
    // onSaveInstanceState(). We restore some state in onCreate() while we can optionally restore
    // other state here, possibly usable after onStart() has completed.
    // The savedInstanceState Bundle is same as the one used in onCreate().
    @Override
    public void onRestoreInstanceState(Bundle savedInstanceState) {
        mTextView.setText(savedInstanceState.getString(TEXT_VIEW_KEY));
    }
    
    // invoked when the activity may be temporarily destroyed, save the instance state here
    @Override
    public void onSaveInstanceState(Bundle outState) {
        outState.putString(GAME_STATE_KEY, mGameState);
        outState.putString(TEXT_VIEW_KEY, mTextView.getText());
    
        // call superclass to save any view hierarchy
        super.onSaveInstanceState(outState);
    }
    
  在onCreate（）方法完成执行后，activity进入“已启动”状态，系统会快速调用onStart（）和onResume（）方法。

- **onStart()**

  当activity进入“开始”状态时，系统将调用此回调。onStart（）调用使activity对用户可见，因为应用程序准备activity进入前台并成为交互式.例如，该方法是应用程序初始化维护UI的代码的位置。它也可以注册一个BroadcastReceiver来监视UI中所反映的更改。
  
  onStart（）方法非常快速地完成，与“创建”状态一样，activity不会保持在“已启动”状态。一旦这个回调结束，activity进入Resumed状态，系统调用onResume（）回调方法。
  
- **onResume()**
  
  当activity进入"onResume"状态的时候，activity进入前台，系统调用"onResume()"回调。这个状态是用户跟App交互的状态，即在"onResume"状态时，activity处于界面最顶端，是可见的具有焦点的能够与用户交互的界面。activity将一直保留在此状态直到发生某些事情将焦点从activity中移开，例如接到电话、用户跳转到另外一个activity、设备屏幕关闭。

  当打断事件发生时，activity进入"onPause"状态，系统调用"onPause()"回调方法。
  
  当activity从"onPause"状态重新进入到"onResume"状态时，系统将再次调用"onResume()"方法。也就是说，当你的activity进入前台时，系统将调用"onResume()"方法，包括第一次创建activity到前台以及activity从其他状态恢复到前台。因此，你应该在"onResume()"方法中初始化那些在"onPause()"方法中释放的组件，也应该执行每次activity进入"onResume"状态时必须发生的任何其他初始化。例如，你应该开始动画和初始化那些activity有焦点才使用的组件。
  
  
          @Override
        public void onResume() {
            super.onResume();  // Always call the superclass method first
        
        
            // Get the Camera instance as the activity achieves full user focus
            if (mCamera == null) {
                initializeCamera(); // Local method to handle camera init
            }
        }
  
  
        @Override
        public void onPause() {
            super.onPause();  // Always call the superclass method first
        
        
            // Release the Camera because we don't need it when paused
            // and other activities might need to use it.
            if (mCamera != null) {
                mCamera.release();
                mCamera = null;
            }
        }
        
- **onPause()**

  系统将此方法称为用户离开activity的第一个指示（尽管并不总是意味着activity被销毁）。使用onPause（）方法来暂停在Activity处于“onpause”状态时不应该继续的动画和音乐播放并且你希望很快恢复的操作。activity进入"onPause"状态一般有如下几个原因。
  
    *一些事件中断了app的执行，这是最常见的情况。*
    
    *在Android 7.0（API24）或更高版本中，多个应用程序以多窗口模式运行（分屏）。由于只有其中一个应用程序（Windows）获取焦点，所以系统会暂停所有其他应用程序。*
    
    *打开一个新的半透明Activity（如对话框）。activity虽然部分可见但没有获取焦点，它将保持"onpause"状态。*
    
  你能够使用"onPause()"方法来释放系统资源，例如广播接收器、传感器手柄、和任何能够影响到电池寿命的资源，而activity处于"onPause()"状态且用户不需要它们。
  
  例如如果你的app使用相机，onPause()方法是释放相机资源的最好地方。
  
  onPause()方法执行相当简短，并不一定有足够的时间执行耗时操作。因此，你不应该在"onPause()"方法里执行保存应用或用户数据、网络连接、数据库事物等操作，在"onPause()"方法完成之前，这些操作可能并未完成。相反，你应该在onStop()方法里执行一些重负载，耗时，关闭等操作。
  
  onPause（）方法的完成并不意味着Activity离开Paused状态。相反，activity保持在这种状态直到activity恢复或者对用户完全不可见。如果activity恢复，系统将再次调用onResume()方法。如果activity从　"onPause"状态重新返回到"onResume"状态，"onPause"状态时系统会将activity实例保留在内存中，当返回到"onResume"状态时再重新调用该实例。在这种情况下，onResume状态创建的组件你不需要重新初始化。如果activity变成完全不可见，系统将调用onStop()方法。
  
  
          @Override
        public void onResume() {
            super.onResume();  // Always call the superclass method first
        
        
            // Get the Camera instance as the activity achieves full user focus
            if (mCamera == null) {
                initializeCamera(); // Local method to handle camera init
            }
        }
  
  
        @Override
        public void onPause() {
            super.onPause();  // Always call the superclass method first
        
        
            // Release the Camera because we don't need it when paused
            // and other activities might need to use it.
            if (mCamera != null) {
                mCamera.release();
                mCamera = null;
            }
        }
        
- **onStop()**

  当activity对用户不可见的时候，它将进入"onStop"状态，系统将调用onStop()回调方法。例如，当一个新的activity覆盖整个屏幕的时候。还有当activity结束运行的时候，系统会调用onStop()方法，并且activity即将被终止。
  
  在onStop()方法中，app应该释放几乎所有不需要的资源，而且用户没有使用它。例如，如果您在onStart()中注册了BroadcastReceiver以监听可能影响用户界面的更改，则可以在onStop()中注销广播接收者，因为用户无法再看到UI。同样重要的是您可以使用onStop（）来释放可能泄漏内存的资源。因为系统可能在不调用onDestroy()回调的情况下杀死托管activity的进程。
  
  您还应该使用onStop()执行相对CPU密集型关机操作.例如，如果您无法找到更适合的时间来将信息保存到数据库，则可以在onStop()中来执行。以下示例显示了将持久性存内容在onStop()中保存的实现：
  
  当activity进入到"onStop"状态时，activity对象保存在内存中，它维护所有的状态和成员信息，但是没有附加到窗口管理器上。当activity恢复的时候将重新调用这些信息。您不需要重新初始化在导致恢复状态的任何回调方法期间创建的组件。系统还会跟踪布局中每个View对象的当前状态，因此如果用户将文本输入到EditText小部件中，则会保留该内容，因此您不需要保存并还原它。
  
  一旦您的activity 进入onStop，如果系统需要恢复内存，系统可能会销毁包含该activity的进程。即使系统在activity停止时销毁进程，系统仍然保留Bundle中的View对象（例如EditText小部件中的文本）的状态（键值对），并且如果用户返回到活动，则还原它们。
  
  从停止状态，activity或者回到与用户交互，或者完成运行并消失。如果activity返回，系统将调用onRestart（）。如果Activity完成运行，系统调用onDestroy（）。
  
- **onDestroy()**

  当activity被销毁时候调用onDestory()方法。这是activity的最后一个回调方法。系统调用此回调，因为activity正在由于某人的调用finish（）完成，或者因为系统暂时摧毁包含activity的进程以节省空间。您可以使用isFinishing（）方法区分这两种场景。当设置方向更改发生时，系统也可能调用此方法，然后立即调用onCreate（）以新方向重新创建进程（以及它包含的组件）。
  
  onDestroy（）方法释放了尚未由较早回调（如onStop（））释放的所有资源。
  
### 3.4 Activity跳转的生命周期

  当一个activity启动另一个活动时，他们都会经历生命周期过渡。第一个activity停止运行并进入 'paused'或者"stopped"状态。当另一个activity被创建的时候。

## 4. Activity状态

  系统从不直接杀死activity。相反，它会杀死activity运行的进程，不仅会销毁activity，而且还会销毁进程中运行的其他任何内容。
  
  当需要释放RAM时，系统会杀死进程;杀死某一进程的可能性取决于当时进程的状态。进程状态依赖于进程中运行的activity的状态。
  
  用户还可以通过使用“设置”下的应用程序管理器来杀死相应的应用程序。
  
  

进程被杀死的可能性 | 进程状态 | activity状态
---|---|---
Least | Foreground (having or about to get focus) | Created Started Resumed
More | Background (lost focus) | Paused
Most | Background (not visible) | Stopped
Most | Empty | Destroyed

## 5. Activity的跳转

  App运行时，可能进入或者退出某一个activity很多次。例如，用户可以点击设备的“后退”按钮，或者activity可能需要启动另一个不同的activity。


  根据您的activity是否需要从即将开始的新activity中获取返回结果，您可以使用startActivity（）或startActivityForResult（）方法启动新activity。不管哪种跳转方式，都需要传入intent对象。

  Intent对象指定要启动的确切activity(显示启动)或描述要执行的操作类型（隐私启动，系统为您选择适当的activity，甚至来自于其他App).一个Intent对象也可以携带少量数据，以便被启动的activity使用.
  
### 5.1 startActivity()

  如果新启动的activity不需要返回结果，则当前activity可以通过调用startActivity（）方法来启动。
  
    Intent intent = new Intent(this, SignInActivity.class);
    startActivity(intent);
    
您的应用程序可能还需要使用activity中的数据执行某些操作，例如发送电子邮件，短信或状态更新.在这种情况下，您的应用程序可能没有自己activity来执行此类操作，因此您可以利用设备上其他应用程序提供的activity，从而可以为您执行操作.这是意图非常有价值的地方：您可以创建一个描述要执行的操作的意图，并且系统从另一个应用程序启动相应的activity。如果有多个可以处理意图的activity，那么用户可以选择使用哪一个。例如，如果要允许用户发送电子邮件，可以创建以下意图：

    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);
    startActivity(intent);
    
额外增加的EXTRA_EMAIL是一个电子邮件地址的字符串数组，电子邮件应发送到该数组。当电子邮件应用程序响应此意图时，它读取额外的字符串数组，并将它们放在电子邮件组合表单的“到”字段中。在这种情况下，电子邮件应用程序的activity开始，用户完成后，您的activity恢复。

### 5.2 startActivityForResult()

  有时你想从activity结束时得到一个返回结果。例如，您可以开始一个activity，让用户在联系人列表中选择一个人; 当它结束时，它返回被选择的人。为此，您调用startActivityForResult（Intent，int）方法，其中整数参数标识该调用。这个标识符是为了消除来自同一activity的对startActivityForResult（Intent，int）的多次调用之间的歧义。它不是全局标识符，没有与其他应用程序或activity冲突的风险。结果通过您的onActivityResult（int，int，Intent）方法返回。
  
  当一个activity退出时，它可以调用setResult（int）将数据返回给前一个activity。这个activity必须提供一个result code，这可以是标准结果RESULT_CANCELED，RESULT_OK或从RESULT_FIRST_USER开始的任何自定义值。此外，activity可以可选地返回包含其想要的任何附加数据的Intent对象。前一个activity使用onActivityResult（int，int，Intent）方法以及其最初提供的整数标识符来接收信息。
  
     public class MyActivity extends Activity {
         ...
    
         static final int PICK_CONTACT_REQUEST = 0;
    
         public boolean onKeyDown(int keyCode, KeyEvent event) {
             if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
                 // When the user center presses, let them pick a contact.
                 startActivityForResult(
                     new Intent(Intent.ACTION_PICK,
                     new Uri("content://contacts")),
                     PICK_CONTACT_REQUEST);
                return true;
             }
             return false;
         }
    
         protected void onActivityResult(int requestCode, int resultCode,
                 Intent data) {
             if (requestCode == PICK_CONTACT_REQUEST) {
                 if (resultCode == RESULT_OK) {
                     // A contact was picked.  Here we will just display it
                     // to the user.
                     startActivity(new Intent(Intent.ACTION_VIEW, data));
                 }
             }
         }
     }
## 6. Activity 栈

activity生命周期中，activity a的onpause 之后 activity b 的oncreate，如果这时候从activity B中返回Activity A，则 Activity A不会执行onStop(), 需要activity B的oncreate中执行方法消耗一定的时间才会重现。

activity 的 fragment 中调用 startActivityForRESULT 在 activity的onactivityresult中获取的时候，requestcode值不对。
需要在fragment里调用getactivity.startActivityForResult